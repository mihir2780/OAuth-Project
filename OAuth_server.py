import logging # to log user activities
from flask import Flask, request, jsonify # for flask app usage and using jsonify to serialise python objects
from flask_oauthlib.provider import OAuth2Provider # Use of OAuth 2.0 from flask_oauthlib.provider 
from werkzeug.security import check_password_hash # to check the password hash coming from our user database
import datetime # for using date and time in python
import hashlib # using 256 SHA from this package to secure generation of access tokens
from utils.database import authusers # We are importing our created users from the utils location
import secrets # used this package to generate unique access token every single time
from utils.user_redirecting import redirected  # Ensure redirection is correctly imported

PEPPER_VALUE = 'y12weuyduy92093892i39' # A constant used in access token generation logic with fixed string value
COOLDOWN_PERIOD = 10  # 1 minute of cooldown period. After that access token can be regenerated for the same user
DAILY_ATTEMPTS = 4 # One user can ask tokens up to 4 times a day

application = Flask(__name__) # A variable that calls main program called "__main__"
oauth = OAuth2Provider(application)
# This variable holds the OAuth2Provider, which will handle OAuth 2.0 features within the Flask application. 

# Set up logging to track activities of the server
logging.basicConfig(filename='OAuth_server.log', level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def authentication(username, password): # Authentication logic of users in database
    user_data = authusers.get(username) # fetching "username" from the database "authusers" 
    if user_data and check_password_hash(user_data['password'], password): 
        # Checking user data and password hash which was generated by the database is correct or not. 
        return user_data # if correct return the data that belong to the user
    
def accesstoken_generation(username, scopes): # token for access token generation
    random_data = secrets.token_hex(16) # using variable 'random_data' to store 16-byte hexadecimal value
    password_with_pepper = username + PEPPER_VALUE + random_data # combining all values to create secured token
    created_accesstoken = hashlib.sha256(password_with_pepper.encode()).hexdigest()
    # hashing the combined values using 256-SHA hashing algorithm
    return created_accesstoken, scopes # giving token after all above conditions are satisfied

def user_redirection(username, access_token, scopes):
    # Including the cooldown period as the duration for the redirection script
    redirected(username, access_token, scopes, COOLDOWN_PERIOD)

@application.route('/token', methods=['POST']) # Decorator to set up a route for token in this code 
def generate_access_token_route(): # token route for incoming requests made by users to this server
    
    username = request.form.get('username') # Get the 'username' field from the request's form data
    password = request.form.get('password') #Get the 'password' field from the request's form data
    
    user = authentication(username, password) # authenticating the user using this function

    if not user:
        logging.warning(f"Unauthorized attempt to generate token for user: {username}") # if users gives wrong username or password
        return jsonify({'error': 'Invalid username or password'}), 401  # this is 401 HTTP response for invalid username or password

    if user.get('daily_attempt_count', 0) >= DAILY_ATTEMPTS: # checking if the user has exceeded all his limits for tokens
        logging.info(f"Daily attempt limit reached for user: {username}") # limits for asking tokens has been reached.
        return jsonify({'error': 'Daily attempt limit reached. Try again tomorrow.'}), 401 

    if 'last_token_time' in user:
        time_since_last_attempt = datetime.datetime.now(datetime.timezone.utc) - user['last_token_time'] 
        if time_since_last_attempt.total_seconds() < COOLDOWN_PERIOD: # checks if the cooldown period is respected
            logging.info(f"Attempt to obtain token too quickly for user: {username}") # logging activity 
            return jsonify({'error': 'Please wait before obtaining a new token.'}), 401 # HTTP response code error
    
    scopes = ['email', 'profile']  # Scopes granted while giving access token to the user

    access_token, token_scopes = accesstoken_generation(username, scopes)
    
    user['last_token_time'] = datetime.datetime.now(datetime.timezone.utc)
    # Updates the user's last token generation time and the daily attempt count.
    user['daily_attempt_count'] = user.get('daily_attempt_count', 0) + 1
    
    logging.info(f"Token generated successfully for user: {username}") # log activities
    
    # Log the redirection after token generation and include scopes
    user_redirection(username, access_token, token_scopes)  # Pass all necessary information
    
    return jsonify({'name': user['name'], 'access_token': access_token, 'expires_in': COOLDOWN_PERIOD, 'scopes': token_scopes}), 200
    # Return the access token and related information as a JSON response and 200 is HTTP response code showing successfully send data

if __name__ == '__main__':
    application.run(debug=True) # Run the application in debug mode if executed directly